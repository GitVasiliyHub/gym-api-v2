from datetime import datetime
from typing import Optional

from sqlalchemy import select, text
from fastapi import HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import joinedload, selectinload
from pydantic import BaseModel, ConfigDict

from .base import BaseRepository
from ..manager import base as manager
from ..database.postgres.base import SessionProvider
from ..config import db
from ..models import autogenerated as model
from ..schemas.task import Task, TaskGroupStatus, TaskGroupWithTasks, TaskGroup
from ..schemas.user import MastersGymer, User, UserIn, UserBase


class Res(BaseModel):
    username: str
    gymer_id: int
    
    model_config = ConfigDict(from_attributes=True)

_session_provider = SessionProvider(
    async_mode=True,
    engine_settings={'pool_pre_ping': True},
    db_settings=db
)

class GymRepository(BaseRepository):
    @classmethod
    @_session_provider
    async def add_user_for_master(
        cls,
        master_id: int,
        gymer_id: int,
        session: AsyncSession=None
    ):
        mg = model.MasterGym(
            master_id=master_id,
            gymer_id=gymer_id,
            create_dttm=datetime.now()
        )
        session.add(mg)
        await session.commit()
        await session.refresh(mg)
        return mg  
    
    @classmethod
    @_session_provider
    async def select_user_data(
        cls,
        telegram_id: int,
        session: AsyncSession=None
    ):
        user_stmt = (
            select(model.User)
            .where(model.User.telegram_id == telegram_id)
        )
        user = await session.execute(user_stmt)
        user = user.scalars().first()
        if not user:
            return
        master_stmt = (
            select(model.Master)
            .where(model.Master.user_id == user.user_id)
        )
        master = await session.execute(master_stmt)
        master = master.scalars().first()
        
        gymer_stmt = (
            select(model.Gymer)
            .where(model.Gymer.user_id == user.user_id)
        )
        gymer = await session.execute(gymer_stmt)
        gymer = gymer.scalars().first() 

        return User(
                user_id=user.user_id,
                username=user.username,
                phone=user.phone,
                first_name=user.first_name,
                last_name=user.last_name,
                email=user.email,
                telegram_id=user.telegram_id,
                photo=None,
                master=master,
                gymer=gymer
        )

    @classmethod
    @_session_provider
    async def add_user(
        cls,
        user_data: UserIn,
        session: AsyncSession=None
    ):
        user = model.User(**user_data.model_dump())
        session.add(user)
        await session.flush()
        u = UserBase.model_validate(user)
        
        master = model.Master(user_id=u.user_id, create_dttm=datetime.now())
        gymer = model.Gymer(user_id=u.user_id, create_dttm=datetime.now())
        session.add(master)
        session.add(gymer)
        
        await session.commit()
        await session.refresh(master)
        await session.refresh(gymer)
        
        await cls.add_user_for_master(
            master_id=master.master_id,
            gymer_id=gymer.gymer_id,
            session=session
        )
        
        return await cls.select_user_data(
            telegram_id=u.telegram_id,
            session=session
        )
        
    
    @classmethod
    @_session_provider
    async def select_master_gymers_data(
        cls,
        master_id: int,
        session: AsyncSession=None
    ):
        mg = model.MasterGym
        g = model.Gymer
        u = model.User
        
        sub = select(mg.gymer_id).where(
            mg.master_id == master_id,
            mg.close_dttm.is_(None)
            )
        
        statement = select(
            u.username,
            u.photo,
            g.gymer_id
        ).join(
            g, g.user_id == u.user_id
        ).where(g.gymer_id.in_(sub))
        
        rows = await session.execute(statement)

        result = []
        for row in rows:
            result.append(Res.model_validate(row))
        
        return result
    
    @classmethod
    @_session_provider
    async def create_task_group(
        cls,
        master_id: int,
        gymer_id: int,
        properties: dict,
        session: AsyncSession = None
    ):
        stmt = select(model.MasterGym.gymer_id).where(
            model.MasterGym.master_id == master_id,
            model.MasterGym.close_dttm.is_(None)
        )
        user = await session.execute(stmt)
        
        if not user.scalars().all():
            raise HTTPException(
                status_code=404,
                detail="there is no master_id for gymer_id"
            )
        task_group = model.TaskGroup(
            master_id=master_id,
            gymer_id=gymer_id,
            properties=properties,
            status=TaskGroupStatus.planned
        )
        session.add(task_group)
        await session.commit()
        await session.refresh(task_group)
        return task_group
    
    @classmethod
    @_session_provider   
    async def get_tasks_by_group(
        cls,
        task_group_id: int,
        session: AsyncSession = None
    ):
        t = model.Task
        stmt = select(t).where(t.task_group_id == task_group_id)
        
        result = await session.execute(stmt)

        return result.scalars().all()
    
    @classmethod
    @_session_provider  
    async def copy_task_group(
        cls,
        task_group_id: int,
        session: AsyncSession = None
    ):
        group = await cls.get_task_group_by_id(
            task_group_id=task_group_id,
            session=session
        )
       
        group = TaskGroup.model_validate(group)
        
        stmt = select(model.TaskGroup).where(
            model.TaskGroup.task_group_id == task_group_id
        ).options(
            joinedload(model.TaskGroup.task)
            .joinedload(model.Task.exercise_desc)
            .joinedload(model.ExerciseDesc.exercise)
        )
         
        result = await session.execute(stmt)
        task_group = result.scalars().unique().one()
        
        tg_with_task = TaskGroupWithTasks.model_validate(task_group)
        
        new_group = await cls.create_task_group(
            master_id=group.master_id,
            gymer_id=group.gymer_id,
            properties={},
        )
        new_task_group_id = new_group.task_group_id
        for task in tg_with_task.task:
            await cls.create_task(
                task_group_id=new_task_group_id,
                exercise_desc_id=task.exercise_desc.exercise_desc_id,
                properties=task.properties.model_dump(),
                session=session
            )
        
        stmt = select(model.TaskGroup).where(
            model.TaskGroup.task_group_id == new_task_group_id
        ).options(
            joinedload(model.TaskGroup.task)
            .joinedload(model.Task.exercise_desc)
            .joinedload(model.ExerciseDesc.exercise)
        )
         
        result = await session.execute(stmt)
        return result.scalars().unique().one()  
        
    
    @classmethod
    @_session_provider
    async def get_exercises_by_master(
        cls,
        master_id: int,
        search: Optional[str] = None,
        session: AsyncSession = None
    ):
        query = select(model.Exercise).where(
            model.Exercise.master_id.in_([1, master_id])
        )
        
        if search:
            query = query.where(model.Exercise.title.ilike(f'%%{search}%%'))
        
        query = query.order_by(model.Exercise.title)
        
        result = await session.execute(query)
        return result.scalars().all()
    
    @classmethod
    @_session_provider
    async def create_task(
        cls,
        task_group_id: int,
        exercise_desc_id: int,
        properties: dict,
        session: AsyncSession = None
    ):
        task = model.Task(
            task_group_id=task_group_id,
            exercise_desc_id=exercise_desc_id,
            properties=properties
        )
        session.add(task)
        await session.commit()
        await session.refresh(task)
        return task
    
    @classmethod
    @_session_provider
    async def update_task(
        cls,
        task_id: int,
        exercise_desc_id: Optional[int] = None,
        status: Optional[str] = None,
        properties: Optional[dict] = None,
        session: AsyncSession = None
    ):
        task = await session.get(model.Task, task_id)
        if not task:
            return None
        
        if status:
            task.status = status
        if properties:
            task.properties = properties
        if exercise_desc_id:
            task.exercise_desc_id = exercise_desc_id
        
        task.update_dttm = datetime.utcnow()
        await session.commit()
        await session.refresh(task)
        return task

    @classmethod
    @_session_provider
    async def get_exercise_by_id(
        cls,
        exercise_id: int,
        session: AsyncSession = None
    ):
        return await session.get(model.Exercise, exercise_id)
    
    @classmethod
    @_session_provider
    async def get_exercise_descriptions(
        cls,
        exercise_id: int,
        session: AsyncSession = None
    ):
        stmt = select(model.ExerciseDesc).options(
                selectinload(model.ExerciseDesc.exercise)
            ).where(
            model.ExerciseDesc.exercise_id == exercise_id
        )
        result = await session.execute(stmt)
        return result.scalars().all()
    
    @classmethod
    @_session_provider
    async def get_master_task_groups_with_tasks(
        cls,
        gymer_id: int,
        limit: int,
        offset: int,
        master_id: Optional[int] = None,
        session: AsyncSession = None
    ):
        where_cond = [
            model.TaskGroup.gymer_id == gymer_id
        ]
        if master_id:
            where_cond.append(
                model.TaskGroup.master_id == master_id
            )
        stmt = select(model.TaskGroup).where(
            *where_cond
        ).options(
            joinedload(model.TaskGroup.task)
            .joinedload(model.Task.exercise_desc)
            .joinedload(model.ExerciseDesc.exercise)
        ).offset(offset).limit(limit)
        # if master_id:
        #     stmt = stmt.where(
        #         model.TaskGroup.master_id == master_id
        #     )
         
        result = await session.execute(stmt)
        return result.scalars().unique().all()
    
    @classmethod
    @_session_provider   
    async def get_task_groups(
        cls,
        status: TaskGroupStatus,
        gymer_id: Optional[int] = None,
        master_id: Optional[int] = None,
        session: AsyncSession = None
    ):
        where_cond = [
            model.TaskGroup.status == status.value
        ]
        
        if gymer_id:
            where_cond.append(model.TaskGroup.gymer_id == gymer_id)
        if master_id:
            where_cond.append(model.TaskGroup.master_id == master_id)
                     
        stmt = select(model.TaskGroup).where(
            *where_cond
        ).options(
            joinedload(model.TaskGroup.task)
            .joinedload(model.Task.exercise_desc)
            .joinedload(model.ExerciseDesc.exercise)
        )

        result = await session.execute(stmt)
        return result.scalars().unique().all()
    
    @classmethod
    @_session_provider   
    async def get_task_group_by_id(
        cls,
        task_group_id: int,
        session: AsyncSession = None
    ):
        t = model.TaskGroup
        stmt = select(t).where(t.task_group_id == task_group_id)
                     
        result = await session.execute(stmt)

        return result.scalars().one()
    
    @classmethod
    @_session_provider      
    async def get_task_group_by_task_id(
        cls,
        task_id: int,
        session: AsyncSession = None
    ):
        t = model.Task
        stmt = select(t).where(t.task_id == task_id).options(
            joinedload(t.task_group)
        )
        result = await session.execute(stmt)

        return result.scalars().one()
    
    @classmethod
    @_session_provider  
    async def update_task_group_status(
        cls,
        task_group_id: int,
        status: TaskGroupStatus,
        session: AsyncSession = None
    ):
        task_group = await session.get(model.TaskGroup, task_group_id)
        if not task_group:
            return None
   
        task_group.status = status.value
        
        task_group.update_dttm = datetime.utcnow()
        if status == TaskGroupStatus.running:
            task_group.start_dttm = datetime.utcnow()
        await session.commit()
        await session.refresh(task_group)
        return task_group  
    
    @classmethod
    @_session_provider   
    async def get_task_by_id(
        cls,
        task_id: int,
        session: AsyncSession = None
    ):
        t = model.Task
        stmt = select(t).where(t.task_id == task_id).options(
                        joinedload(model.Task.exercise_desc)
            .joinedload(model.ExerciseDesc.exercise)
        )
                     
        result = await session.execute(stmt)

        return result.scalars().unique().first()