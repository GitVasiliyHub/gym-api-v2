from typing import Optional

from sqlalchemy import select, text
from fastapi import HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import joinedload, selectinload
from pydantic import BaseModel, ConfigDict

from .base import BaseRepository
from ..manager import base as manager
from ..database.postgres.base import SessionProvider
from ..config import db
from ..models import autogenerated as model
from ..schemas.task import Task



class Res(BaseModel):
    username: str
    gymer_id: int
    
    model_config = ConfigDict(from_attributes=True)

_session_provider = SessionProvider(
    async_mode=True,
    engine_settings={'pool_pre_ping': True},
    db_settings=db
)

class GymRepository(BaseRepository):
    @classmethod
    @_session_provider
    async def select_master_gymers_data(
        cls,
        master_id: int,
        session: AsyncSession=None
    ):
        mg = model.MasterGym
        g = model.Gymer
        u = model.User
        
        sub = select(mg.gymer_id).where(
            mg.master_id == master_id,
            mg.close_dttm.is_(None)
            )
        
        statement = select(
            u.username,
            g.gymer_id
        ).join(
            g, g.user_id == u.user_id
        ).where(g.gymer_id.in_(sub))
        
        rows = await session.execute(statement)

        result = []
        for row in rows:
            result.append(Res.model_validate(row))
        
        return result
    
    @classmethod
    @_session_provider
    async def create_task_group(
        cls,
        master_id: int,
        gymer_id: int,
        properties: dict,
        session: AsyncSession = None
    ):
        task_group = model.TaskGroup(
            master_id=master_id,
            gymer_id=gymer_id,
            properties=properties,
            status='planned'
        )
        session.add(task_group)
        await session.commit()
        await session.refresh(task_group)
        return task_group
    
    @classmethod
    @_session_provider   
    async def get_tasks_by_group(
        cls,
        task_group_id: int,
        session: AsyncSession = None
    ):
        t = model.Task
        stmt = select(t).where(t.task_group_id == task_group_id)
        
        result = await session.execute(stmt)

        return result.scalars().all()
    
    @classmethod
    @_session_provider
    async def get_exercises_by_master(
        cls,
        master_id: int,
        search: Optional[str] = None,
        session: AsyncSession = None
    ):
        query = select(model.Exercise).where(
            model.Exercise.master_id.in_([1, master_id])
        )
        
        if search:
            query = query.where(model.Exercise.title.ilike(f'%%{search}%%'))
        print(query, search)
        query = query.order_by(model.Exercise.title)
        
        result = await session.execute(query)
        return result.scalars().all()
    
    @classmethod
    @_session_provider
    async def create_task(
        cls,
        task_group_id: int,
        exercise_desc_id: int,
        properties: dict,
        session: AsyncSession = None
    ):
        task = model.Task(
            task_group_id=task_group_id,
            exercise_desc_id=exercise_desc_id,
            properties=properties,
            status='planned'
        )
        session.add(task)
        await session.commit()
        await session.refresh(task)
        return task
    
    @classmethod
    @_session_provider
    async def update_task(
        cls,
        task_id: int,
        status: Optional[str] = None,
        properties: Optional[dict] = None,
        session: AsyncSession = None
    ):
        task = await session.get(model.Task, task_id)
        if not task:
            return None
        
        if status:
            task.status = status
        if properties:
            task.properties = properties
        
        task.update_dttm = datetime.utcnow()
        await session.commit()
        await session.refresh(task)
        return task

    @classmethod
    @_session_provider
    async def get_exercise_by_id(
        cls,
        exercise_id: int,
        session: AsyncSession = None
    ):
        return await session.get(model.Exercise, exercise_id)
    
    @classmethod
    @_session_provider
    async def get_exercise_descriptions(
        cls,
        exercise_id: int,
        session: AsyncSession = None
    ):
        stmt = select(model.ExerciseDesc).options(
                selectinload(model.ExerciseDesc.exercise)
            ).where(
            model.ExerciseDesc.exercise_id == exercise_id
        )
        result = await session.execute(stmt)
        return result.scalars().all()
    
    @classmethod
    @_session_provider
    async def get_master_task_groups_with_tasks(
        cls,
        gymer_id: int,
        limit: int,
        offset: int,
        master_id: Optional[int] = None,
        session: AsyncSession = None
    ):
        where_cond = [
            model.TaskGroup.gymer_id == gymer_id
        ]
        if master_id:
            where_cond.append(
                model.TaskGroup.master_id == master_id
            )
        stmt = select(model.TaskGroup).where(
            *where_cond
        ).options(
            joinedload(model.TaskGroup.task)
            .joinedload(model.Task.exercise_desc)
            .joinedload(model.ExerciseDesc.exercise)
        ).offset(offset).limit(limit)
        # if master_id:
        #     stmt = stmt.where(
        #         model.TaskGroup.master_id == master_id
        #     )
        
        
        
        result = await session.execute(stmt)
        return result.scalars().unique().all()
    
    @classmethod
    @_session_provider   
    async def get_task_groups(
        cls,
        status: str,
        gymer_id: Optional[int] = None,
        master_id: Optional[int] = None,
        session: AsyncSession = None
    ):
        t = model.TaskGroup
        stmt = select(t).where(t.status == status)
        
        if gymer_id:
            stmt = stmt.where(t.gymer_id == gymer_id)
        if master_id:
            stmt = stmt.where(t.master_id == master_id)
                     
        result = await session.execute(stmt)

        return result.scalars().all()
    
    @classmethod
    @_session_provider   
    async def get_task_group_by_id(
        cls,
        task_group_id: str,
        session: AsyncSession = None
    ):
        t = model.TaskGroup
        stmt = select(t).where(t.task_group_id == task_group_id)
                     
        result = await session.execute(stmt)

        return result.scalars().one()