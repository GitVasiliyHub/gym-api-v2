from datetime import datetime
from typing import Optional, List

from sqlalchemy import update, bindparam
from sqlalchemy import select, text
from fastapi import HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import joinedload, selectinload

from .base import BaseRepository
from ..database.postgres.base import SessionProvider
from ..config import db
from ..models import autogenerated as model
from ..schemas.task import (
    Task, 
    TaskGroupStatus, 
    TaskGroupWithTasks, 
    TaskGroup, TaskGroupOrderIndex, TaskOrderIndex
)


_session_provider = SessionProvider(
    async_mode=True,
    engine_settings={'pool_pre_ping': True},
    db_settings=db
)

class GymRepository(BaseRepository):    

    
    @classmethod
    @_session_provider
    async def create_task_group(
        cls,
        master_id: int,
        gymer_id: int,
        properties: dict,
        session: AsyncSession = None
    ):
        stmt = select(model.MasterGym.gymer_id).where(
            model.MasterGym.master_id == master_id,
            model.MasterGym.close_dttm.is_(None)
        )
        user = await session.execute(stmt)
        
        if not user.scalars().all():
            raise HTTPException(
                status_code=404,
                detail="there is no master_id for gymer_id"
            )
        task_group = model.TaskGroup(
            master_id=master_id,
            gymer_id=gymer_id,
            properties=properties,
            status=TaskGroupStatus.planned
        )
        session.add(task_group)
        await session.commit()
        await session.refresh(task_group)
        return task_group
    
    @classmethod
    @_session_provider   
    async def get_tasks_by_group(
        cls,
        task_group_id: int,
        session: AsyncSession = None
    ):
        t = model.Task
        stmt = select(t).where(t.task_group_id == task_group_id)
        
        result = await session.execute(stmt)

        return result.scalars().all()
    
    @classmethod
    @_session_provider  
    async def copy_task_group(
        cls,
        task_group_id: int,
        session: AsyncSession = None
    ):
        group = await cls.get_task_group_by_id(
            task_group_id=task_group_id,
            session=session
        )
       
        group = TaskGroup.model_validate(group)
        
        stmt = select(model.TaskGroup).where(
            model.TaskGroup.task_group_id == task_group_id
        ).options(
            joinedload(model.TaskGroup.task)
            .joinedload(model.Task.exercise_desc)
            .joinedload(model.ExerciseDesc.exercise)
        )
         
        result = await session.execute(stmt)
        task_group = result.scalars().unique().one()
        
        tg_with_task = TaskGroupWithTasks.model_validate(task_group)
        
        new_group = await cls.create_task_group(
            master_id=group.master_id,
            gymer_id=group.gymer_id,
            properties={},
        )
        new_task_group_id = new_group.task_group_id
        for task in tg_with_task.task:
            await cls.create_task(
                task_group_id=new_task_group_id,
                exercise_desc_id=task.exercise_desc.exercise_desc_id,
                properties=task.properties.model_dump(),
                session=session
            )
        
        stmt = select(model.TaskGroup).where(
            model.TaskGroup.task_group_id == new_task_group_id
        ).options(
            joinedload(model.TaskGroup.task)
            .joinedload(model.Task.exercise_desc)
            .joinedload(model.ExerciseDesc.exercise)
        )
         
        result = await session.execute(stmt)
        return result.scalars().unique().one()  
        
    
    # @classmethod
    # @_session_provider
    # async def get_exercises_by_master(
    #     cls,
    #     master_id: int,
    #     search: Optional[str] = None,
    #     session: AsyncSession = None
    # ):
    #     query = select(model.Exercise).where(
    #         model.Exercise.master_id.in_([1, master_id])
    #     )
    #
    #     if search:
    #         query = query.where(model.Exercise.title.ilike(f'%%{search}%%'))
    #
    #     query = query.order_by(model.Exercise.title)
    #
    #     result = await session.execute(query)
    #     return result.scalars().all()
    
    @classmethod
    @_session_provider
    async def create_task(
        cls,
        task_group_id: int,
        exercise_desc_id: int,
        properties: dict,
        session: AsyncSession = None
    ):
        task = model.Task(
            task_group_id=task_group_id,
            exercise_desc_id=exercise_desc_id,
            properties=properties
        )
        session.add(task)
        await session.commit()
        await session.refresh(task)
        return task
    
    @classmethod
    @_session_provider
    async def update_task(
        cls,
        task_id: int,
        exercise_desc_id: Optional[int] = None,
        status: Optional[str] = None,
        properties: Optional[dict] = None,
        session: AsyncSession = None
    ):
        task = await session.get(model.Task, task_id)
        if not task:
            return None
        
        if status:
            task.status = status
        if properties:
            task.properties = properties
        if exercise_desc_id:
            task.exercise_desc_id = exercise_desc_id
        
        task.update_dttm = datetime.utcnow()
        await session.commit()
        await session.refresh(task)
        return task

    @classmethod
    @_session_provider
    async def get_exercise_by_id(
        cls,
        exercise_id: int,
        session: AsyncSession = None
    ):
        return await session.get(model.Exercise, exercise_id)
    
    # @classmethod
    # @_session_provider
    # async def get_exercise_descriptions(
    #     cls,
    #     exercise_id: int,
    #     session: AsyncSession = None
    # ):
    #     stmt = select(model.ExerciseDesc).options(
    #             selectinload(model.ExerciseDesc.exercise)
    #         ).where(
    #         model.ExerciseDesc.exercise_id == exercise_id
    #     )
    #     result = await session.execute(stmt)
    #     return result.scalars().all()
    
    @classmethod
    @_session_provider
    async def get_master_task_groups_with_tasks(
        cls,
        gymer_id: int,
        limit: int,
        offset: int,
        master_id: Optional[int] = None,
        session: AsyncSession = None
    ):
        where_cond = [
            model.TaskGroup.gymer_id == gymer_id
        ]
        if master_id:
            where_cond.append(
                model.TaskGroup.master_id == master_id
            )
        stmt = select(model.TaskGroup).where(
            *where_cond
        ).options(
            joinedload(model.TaskGroup.task)
            .joinedload(model.Task.exercise_desc)
            .joinedload(model.ExerciseDesc.exercise)
        ).offset(offset).limit(limit)
        # if master_id:
        #     stmt = stmt.where(
        #         model.TaskGroup.master_id == master_id
        #     )
         
        result = await session.execute(stmt)
        return result.scalars().unique().all()
    
    @classmethod
    @_session_provider   
    async def get_task_groups(
        cls,
        status: TaskGroupStatus,
        gymer_id: Optional[int] = None,
        master_id: Optional[int] = None,
        session: AsyncSession = None
    ):
        where_cond = [
            model.TaskGroup.status == status.value
        ]
        
        if gymer_id:
            where_cond.append(model.TaskGroup.gymer_id == gymer_id)
        if master_id:
            where_cond.append(model.TaskGroup.master_id == master_id)
                     
        stmt = select(model.TaskGroup).where(
            *where_cond
        ).options(
            joinedload(model.TaskGroup.task)
            .joinedload(model.Task.exercise_desc)
            .joinedload(model.ExerciseDesc.exercise)
        )

        result = await session.execute(stmt)
        return result.scalars().unique().all()
    
    @classmethod
    @_session_provider   
    async def get_task_group_by_id(
        cls,
        task_group_id: int,
        session: AsyncSession = None
    ):
        t = model.TaskGroup
        stmt = select(t).where(t.task_group_id == task_group_id)
                     
        result = await session.execute(stmt)

        return result.scalars().one()
    
    @classmethod
    @_session_provider      
    async def get_task_group_by_task_id(
        cls,
        task_id: int,
        session: AsyncSession = None
    ):
        t = model.Task
        stmt = select(t).where(t.task_id == task_id).options(
            joinedload(t.task_group)
        )
        result = await session.execute(stmt)

        return result.scalars().one()
    
    @classmethod
    @_session_provider  
    async def update_task_group_status(
        cls,
        task_group_id: int,
        status: TaskGroupStatus,
        session: AsyncSession = None
    ):
        task_group = await session.get(model.TaskGroup, task_group_id)
        if not task_group:
            return None
   
        task_group.status = status.value
        
        task_group.update_dttm = datetime.utcnow()
        if status == TaskGroupStatus.running:
            task_group.start_dttm = datetime.utcnow()
        await session.commit()
        await session.refresh(task_group)
        return task_group  
    
    @classmethod
    @_session_provider   
    async def get_task_by_id(
        cls,
        task_id: int,
        session: AsyncSession = None
    ):
        t = model.Task
        stmt = select(t).where(t.task_id == task_id).options(
                        joinedload(model.Task.exercise_desc)
            .joinedload(model.ExerciseDesc.exercise)
        )
                     
        result = await session.execute(stmt)

        return result.scalars().unique().first()
    
    @classmethod
    @_session_provider  
    async def reorder_task_group(
        cls,
        ordered_ids: List[TaskGroupOrderIndex],
        session: AsyncSession = None
    ):
        await session.execute(
            update(model.TaskGroup),
            [
            {
                "task_group_id": data.task_group_id,
                "order_idx": data.order_idx,
                "update_dttm": datetime.now()
            }
            for data in ordered_ids
        ]
            
        )
        await session.commit()
        
    @classmethod
    @_session_provider  
    async def reorder_task(
        cls,
        ordered_ids: List[TaskOrderIndex],
        session: AsyncSession = None
    ):
        await session.execute(
            update(model.Task),
            [
            {
                "task_id": data.task_id,
                "order_idx": data.order_idx,
                "update_dttm": datetime.now()
            }
            for data in ordered_ids
        ]
            
        )
        await session.commit()
        